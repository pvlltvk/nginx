user    nginx;
worker_processes    auto;

# Уменьшает число системных вызовов gettimeofday(), что приводит к увеличению производительности
timer_resolution    100ms;

# [ debug | info | notice | warn | error | crit ]
error_log    /var/log/nginx/error.log info;

events {
    # Увеличиваем максимальное количество соединений одного рабочего процесса.
    worker_connections    8192;

    # Будет принимать максимально возможное количество соединений
    multi_accept    on;
}

http {
    include    mime.types;
    default_type    application/octet-stream;

    # Метод отправки данных sendfile более эффективен, чем стандартный метод read+write
    sendfile    on;

    # Разрешает или запрещает использование параметра сокета TCP_NOPUSH во FreeBSD или TCP_CORK в Linux. Параметр включаются только при использовании sendfile. Включение параметра позволяет:
    # 1. передавать заголовок ответа и начало файла в одном пакете;
    # 2. передавать файл полными пакетами.
    tcp_nopush    on;

    # Отключение алгоритма Нейгла, включается только при переходе соединения в режим keep-alive
    tcp_nodelay    on;

    # Увеличиваем размер буфера для тела запроса клиента (по умолчанию 8k)
    client_body_buffer_size    128k;

    # Уменьшаем таймаут при чтении тела запроса клиента (по умолчанию 60s)
    client_body_timeout    15s;

    # Уменьшаем таймаут при чтении заголовка запроса клиента (по умолчанию 60s)
    client_header_timeout    15s;

    # Увеличиваем ограничение на размер тела запроса клиента (по умолчанию 1m)
    client_max_body_size    8m;

    # Будет ждать 20 секунд перед закрытием keepalive соединения
    keepalive_timeout    60s;

    # Максимальное количество keepalive запросов от одного клиента
    keepalive_requests    100;

    # Разрешаем серверу сброс соединений по таймауту
    reset_timedout_connection    on;

    # Уменьшаем таймаут при передаче ответа клиенту (по умолчанию 60s), если по истечении этого времени клиент ничего не примет, соедниение будет закрыто
    send_timeout    15s;

    # Минимальный размер файла для прямого чтения с диска, в обход файлового кэша
    directio    8m;

    # В случае необходимости включаем ограничение скорости:
    
    # Порог отдачи, после которого начинает действовать ограничение скорости
    #limit_rate_after    2m;

    # Ограничение на скорость скачивания в рамках одного запроса - экономим полосу пропускания
    #limit_rate    196K;

    # Настраиваем кэш, в котором хранятся дескрипторы открытых файлов, информация об их размерах и времени модифиакции, информация о существовании каталогов, информация об ошибках поиска файла:

    # Включаем кэш, определяет максимальное количество файлов, информация о которых будет содержаться в кеше и время через которое элемент кэша удаляется, если к нему не было обращений
    open_file_cache    max=2000 inactive=20s;

    # Определяет время, через которое следует проверять актуальность информации об элементе
    open_file_cache_valid    20s;

    # Будет кешировать информацию о тех файлах, которые были использованы хотя бы 2 раза
    open_file_cache_min_uses    2;

    # Будет кешировать информацию об отсутствующих файлах
    open_file_cache_errors    on;

    # Увеличиваем максимальный размер хэш-таблиц имен серверов ( по умолчанию 512)
    server_names_hash_max_size    262144;

    # Не показываем версию nginx
    server_tokens    off;

    # Задаем URI, который будет показываться для данных ошибок (также смотрим error_page/50x_location)
    #error_page	500 501 502 503 504 /50x.html;

    # Определяем формат access-логов
    include    log/format;

    # Если используем nginx как reverse proxy, подключаем конфиги в каталоге proxy:
    #include    proxy/settings;
    #include    proxy/buffers;

    # Если необходим балансировка нагрузки и/или failover, редактируем и подключаем конфиг в каталоге upstream:
    #include    upstream/backend;

    # Если работаем с FastCGI-сервером, подключаем конфиги в каталоге fastcgi:
    #include    fastcgi/buffers;

    # Если необходимо кэшировать ответы от проксируемого сервера включаем:
    #include    proxy/cache;

    # Включаем сжатие ответов gzip-ом 
    include    gzip/static_and_module;

    # Добавляем полезные поля в заголовки ответа
    include    security/add_header;

    # Для доступа к внутренней статистики nginx подключаем конфиг:
    #include    stub/status;

    include vhosts.d/*;
}
